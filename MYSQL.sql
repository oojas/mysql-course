# SELECT STATEMENTS;
# THESE ARE THE SQL NOTES ALL THE QUERIES ARE EXPLAINED IN THE COMMENTS IN THE SCRIPT ONLY
SELECT FIRST_NAME,LAST_NAME FROM EMPLOYEES;
# star means all
SELECT *FROM EMPLOYEES; # THE STAR WILL GIVE US ALL THE DATA FROM ALL THE COLUMNS

# WHERE CLAUSE : IT ALLOWS US TO SET A CONDITIONS WE WANT TO RETRIEVE.
SELECT *FROM EMPLOYEES WHERE FIRST_NAME='GEORGI';
SELECT * FROM EMPLOYEES WHERE FIRST_NAME="ELVIS";

# OPERATORS : AND, IN , OR, LIKE, BETWEEN, NOT IN, NOT IN ;
# AND : ALLOWS YOU TO LOGICALLY COMBINE TWO STATEMENTS IN THE CONDITION CODE BLOCK;
#EG:
SELECT *FROM EMPLOYEES WHERE FIRST_NAME='DENIS' AND GENDER='M';
SELECT * FROM EMPLOYEES WHERE FIRST_NAME='Kellie' AND GENDER='F';

# IN AND ALL THE CONDITIONS SHOULD BE TRUE BUT IN OR EVEN IF ONE CONDITION IS TRUE IT GETS EXECUTED;
#EG
SELECT * FROM EMPLOYEES WHERE FIRST_NAME='DENIS' OR FIRST_NAME ='ELVIS';
SELECT * FROM EMPLOYEES WHERE FIRST_NAME='KELLIE' OR FIRST_NAME='ARUNA';

#OPERATOR PRECEDENCE : IF WE ARE USING AND OR IN THE SAME BLOCK AND IS APPLIED FIRST AND OR IS APPLIED SECOND.
SELECT * FROM EMPLOYEES WHERE FIRST_NAME='DENIS' AND GENDER='M' OR GENDER='F';
# THE ABOVE QUERY DOES NOT GIVE THE RIGHT ANSWER DUE TO OPERATOR PRECEDENCE. IN ORDER TO GET CORRECT OUTPUT
# WE USE PARANTHESIS.
SELECT * FROM EMPLOYEES WHERE FIRST_NAME='DENIS' AND (GENDER='M' OR GENDER='F');
SELECT * FROM EMPLOYEES WHERE GENDER='F' AND (FIRST_NAME='KELLIE' OR FIRST_NAME='ARUNA');

# IN:WE USE IN WHEN WE HAVE TO SATISY MORE THAN 2 CONDITIONS.
# NORMAL QUERY
SELECT * FROM EMPLOYEES WHERE FIRST_NAME='DENIS' OR FIRST_NAME='ARUNA' OR FIRST_NAME='KELLIE';
# WITH IN OPREATOR
SELECT * FROM EMPLOYEES WHERE FIRST_NAME IN('DENIS','KELLIE','ARUNA');
# IN OPERATOR IS FASTER THAN OR IN MULTI CONDITIONAL QUERIES.
# IF WE WANT TO USE MULTI CONDITIONAL QUERY TO OMIT SOMETHING WE USE NOT IN.
# EG : A QUERY WHERE FIRST NAME IS NOT DENIS OR KELLIE OR ARUNA
SELECT * FROM EMPLOYEES WHERE FIRST_NAME NOT IN('DENIS','KELLIE','ARUNA');
SELECT * FROM EMPLOYEES WHERE FIRST_NAME IN('DENIS','ELVIS');
SELECT * FROM EMPLOYEES WHERE FIRST_NAME NOT IN('JOHN','MARK','JACOB');

# LIKE NOT LIKE : IF WE NEED TO WATCH A PATTERN WE USE LIKE
# EG: FIND ALL THE DATA OF THE PEOPLE WHOSE FIRST NAME HAS "MAR" IN IT OR "AR" IN IT"
SELECT * FROM EMPLOYEES WHERE FIRST_NAME LIKE('MAR%');
SELECT * FROM EMPLOYEES WHERE FIRST_NAME LIKE('AR%');
# IT IS IMPORTANT TO NOTE THAT % SIGN IS USED TO DENOTE THE SUBSEQUENCE OF CHARACTERS.
# LIKE AND NOT LIKE ARE BASICALLY USED TO PATTERN MATCHING.
 
 #BETWEEN : HELPS TO DESIGNATE THE INTERVAL TO WHICH THE VALUE BELONGS. THAT IS WHY IT IS ALWAYS USED WITH AND 
 #OPERATOR.
 #EG:
 SELECT * FROM EMPLOYEES WHERE HIRE_DATE BETWEEN '1990-01-01' AND '2000-01-01';
 SELECT * FROM SALARIES WHERE SALARY BETWEEN 66000 AND 77000;
 SELECT * FROM EMPLOYEES WHERE EMP_NO NOT BETWEEN 10004 AND 10012;
 SELECT * FROM DEPARTMENTS WHERE DEPT_NO BETWEEN 'D003' AND 'D006';
 
 # NOT NULL CLAUSE IS USED IF WE WANT TO RETRIEVE NON NULL VALUES FROM A COLUMN.
 SELECT FIRST_NAME FROM EMPLOYEES WHERE FIRST_NAME IS NOT NULL;
 SELECT DEPT_NAME FROM DEPARTMENTS WHERE DEPT_NAME IS NOT NULL;
 #DISTINCT : IF WE WANT DISTINCT VALUES
 SELECT DISTINCT GENDER FROM EMPLOYEES;
 SELECT DISTINCT HIRE_DATE FROM EMPLOYEES;
 
 #COUNT : COUNTS THE NON NULL VALUES IN A COLUMN IE GIVES NON NULL ROWS.
 SELECT COUNT(EMP_NO) FROM EMPLOYEES;
 SELECT COUNT(DISTINCT FIRST_NAME) FROM EMPLOYEES;
 # WHILE USING COUNT THE DISTINCT KEYWORD IS NOT WRITTEN AFTER SELECT. IT IS WRITTEN IN COUNT
 # BRACKETS.
 SELECT COUNT(SALARY) FROM SALARIES WHERE SALARY>=100000;
 SELECT COUNT(*) FROM EMPLOYEES;
 
 # ORDER BY : THIS CLAUSE BASICALLY ORDERS THE GIVEN QUERY WITH THE GIVEN PARAMETER.
 SELECT * FROM EMPLOYEES ORDER BY FIRST_NAME;
 SELECT * FROM EMPLOYEES ORDER BY HIRE_DATE;
 
 # GROUP BY:  WHEN WORKING IN SQL, RESULTS CAN BE GROUPED ACCORDING TO A SPECIFIC
 # FIELD OR FIELDS. THIS IS DONE BY GROUP BY. GROUP BY MUST BE PLACED IMMEDIATELY AFTER WHERE AND
 # JUST BEFORE ORDER BY. SUPPOSE WE WANT TO KNOW HOW MANY TIMES FIRST NAME HAS BEEN COME. MEANING
 # HOW MANY TIMES A PARTICULAR NAME IS THERE WE CAN SUE GROUP BY THERE. 
 # A STRICT RULE IS THAT WHATEVER WE USE IN COUNT IN GROUPY BY JUST USE IT BEFORE SELECT.
 #EG:
SELECT COUNT(FIRST_NAME) FROM EMPLOYEES GROUP BY FIRST_NAME;
# THIS MEANS WE ARE GETTING COUNT OF FIRST NAMES AND IN TURN WE ARE ALSO GROUPING THOSE COUNTS 
# ACCORDING TO GROUP BY.
SELECT FIRST_NAME, COUNT(FIRST_NAME) FROM EMPLOYEES GROUP BY FIRST_NAME ORDER BY FIRST_NAME DESC;

# AS : AS IS USED TO CHANGE THE COLUMN NAME.
SELECT FIRST_NAME AS NAMES_PEOPLE,COUNT(FIRST_NAME) AS NAMES_COUNT FROM EMPLOYEES GROUP BY FIRST_NAME ORDER BY FIRST_NAME;
SELECT SALARY, COUNT(EMP_NO) AS EMP_WITH_SAME_SALARY FROM SALARIES WHERE SALARY>80000 GROUP BY SALARY ORDER BY SALARY;

# HAVING: HAVING IS LIKE WHERE BUT IT IS USED BETWEEN GROUP BY AND ORDER BY CALUSE.
#EG: FIND ALL FIRST NAMES WHERE FIRST NAMES ARE MORE THAN 250 TIMES. 
SELECT FIRST_NAME,COUNT(FIRST_NAME) AS NAMES_COUNT FROM EMPLOYEES GROUP BY FIRST_NAME
HAVING COUNT(FIRST_NAME)>250 ORDER BY FIRST_NAME;
# IN WHERE CLAUSE YOU CANNOT USE AGGREGATE FUNCTIONS WITH IT WHEREAS YOU CAN USE IT WITH HAVING.
SELECT FIRST_NAME , COUNT(FIRST_NAME) FROM EMPLOYEES WHERE HIRE_DATE>'1999-01-01' GROUP BY FIRST_NAME
HAVING COUNT(FIRST_NAME)<200 ORDER BY FIRST_NAME;
# THE ABOVE QUERY MEANS SELECTING ALL EMPLOYEES WHO HAVE BEEN HIRED AFTER 1 JAN 1999 HAVING NAMES LESS THAN 200.

# IF USING AGGREGATE FUNCTIONS USE HAVING, IF GENERAL QUERIES USE WHERE.

# LIMITS :  IF WE WANT A CERTAIN NUMBER OF ROWS OR WE WANT TO LIMIT OUR OUTPUT TO CERTAIN VALUES WE USE LIMIT.
#EG:
SELECT * FROM EMPLOYEES LIMIT 100;

# INSERTION IN THE TABLE
INSERT INTO EMPLOYEES VALUES(
13,
'2000-02-13',
'Ojas',
'Gupta',
'M',
'2023-01-16');
SELECT * FROM EMPLOYEES WHERE EMP_NO=13;

#UPDATE : 

UPDATE EMPLOYEES 
SET 
FIRST_NAME='RITU',
LAST_NAME='GUPTA',
BIRTH_DATE='1972-09-08',
GENDER='F'
WHERE EMP_NO=13;

UPDATE EMPLOYEES SET
BIRTH_DATE='1972-09-08',
FIRST_NAME='RITU',
LAST_NAME='GUPTA',
GENDER='F',
HIRE_DATE='2023-01-16'
WHERE EMP_NO=96825;
# COMMIT : SAVES THE CURRENT STATE OF THE DATABASE
# ROLLBACK : GETS TO THE PREVIOUS STATE OF THE DATABASE.
DELETE FROM EMPLOYEES WHERE EMP_NO=13;
SELECT * FROM EMPLOYEES WHERE EMP_NO=96825;
COMMIT;

DELETE FROM DEPARTMENTS WHERE DEPT_NO='d010';
ROLLBACK;
SELECT *FROM DEPARTMENTS ORDER BY DEPT_NO LIMIT 10;

# -------------------------------------------- JOINS----------------------------------------

# INNER JOINS : INNER JOINS ARE BASICALLY THE INTERSECTION OF TWO TABLES WITH SAME COLUMN(S) TO RELATE 
# WITH EACH OTEHR.
USE EMPLOYEES;
SELECT E.EMP_NO , E.FIRST_NAME, E.LAST_NAME, E.HIRE_DATE, D.DEPT_NO
FROM EMPLOYEES E INNER JOIN DEPT_MANAGER D ON E.EMP_NO=D.EMP_NO ORDER BY E.EMP_NO;