# SELECT STATEMENTS;
# THESE ARE THE SQL NOTES ALL THE QUERIES ARE EXPLAINED IN THE COMMENTS IN THE SCRIPT ONLY
SELECT FIRST_NAME,LAST_NAME FROM EMPLOYEES;
# star means all
SELECT *FROM EMPLOYEES; # THE STAR WILL GIVE US ALL THE DATA FROM ALL THE COLUMNS

# WHERE CLAUSE : IT ALLOWS US TO SET A CONDITIONS WE WANT TO RETRIEVE.
SELECT *FROM EMPLOYEES WHERE FIRST_NAME='GEORGI';
SELECT * FROM EMPLOYEES WHERE FIRST_NAME="ELVIS";

# OPERATORS : AND, IN , OR, LIKE, BETWEEN, NOT IN, NOT IN ;
# AND : ALLOWS YOU TO LOGICALLY COMBINE TWO STATEMENTS IN THE CONDITION CODE BLOCK;
#EG:
SELECT *FROM EMPLOYEES WHERE FIRST_NAME='DENIS' AND GENDER='M';
SELECT * FROM EMPLOYEES WHERE FIRST_NAME='Kellie' AND GENDER='F';

# IN AND ALL THE CONDITIONS SHOULD BE TRUE BUT IN OR EVEN IF ONE CONDITION IS TRUE IT GETS EXECUTED;
#EG
SELECT * FROM EMPLOYEES WHERE FIRST_NAME='DENIS' OR FIRST_NAME ='ELVIS';
SELECT * FROM EMPLOYEES WHERE FIRST_NAME='KELLIE' OR FIRST_NAME='ARUNA';

#OPERATOR PRECEDENCE : IF WE ARE USING AND OR IN THE SAME BLOCK AND IS APPLIED FIRST AND OR IS APPLIED SECOND.
SELECT * FROM EMPLOYEES WHERE FIRST_NAME='DENIS' AND GENDER='M' OR GENDER='F';
# THE ABOVE QUERY DOES NOT GIVE THE RIGHT ANSWER DUE TO OPERATOR PRECEDENCE. IN ORDER TO GET CORRECT OUTPUT
# WE USE PARANTHESIS.
SELECT * FROM EMPLOYEES WHERE FIRST_NAME='DENIS' AND (GENDER='M' OR GENDER='F');
SELECT * FROM EMPLOYEES WHERE GENDER='F' AND (FIRST_NAME='KELLIE' OR FIRST_NAME='ARUNA');

# IN:WE USE IN WHEN WE HAVE TO SATISY MORE THAN 2 CONDITIONS.
# NORMAL QUERY
SELECT * FROM EMPLOYEES WHERE FIRST_NAME='DENIS' OR FIRST_NAME='ARUNA' OR FIRST_NAME='KELLIE';
# WITH IN OPREATOR
SELECT * FROM EMPLOYEES WHERE FIRST_NAME IN('DENIS','KELLIE','ARUNA');
# IN OPERATOR IS FASTER THAN OR IN MULTI CONDITIONAL QUERIES.
# IF WE WANT TO USE MULTI CONDITIONAL QUERY TO OMIT SOMETHING WE USE NOT IN.
# EG : A QUERY WHERE FIRST NAME IS NOT DENIS OR KELLIE OR ARUNA
SELECT * FROM EMPLOYEES WHERE FIRST_NAME NOT IN('DENIS','KELLIE','ARUNA');
SELECT * FROM EMPLOYEES WHERE FIRST_NAME IN('DENIS','ELVIS');
SELECT * FROM EMPLOYEES WHERE FIRST_NAME NOT IN('JOHN','MARK','JACOB');

# LIKE NOT LIKE : IF WE NEED TO WATCH A PATTERN WE USE LIKE
# EG: FIND ALL THE DATA OF THE PEOPLE WHOSE FIRST NAME HAS "MAR" IN IT OR "AR" IN IT"
SELECT * FROM EMPLOYEES WHERE FIRST_NAME LIKE('MAR%');
SELECT * FROM EMPLOYEES WHERE FIRST_NAME LIKE('AR%');
# IT IS IMPORTANT TO NOTE THAT % SIGN IS USED TO DENOTE THE SUBSEQUENCE OF CHARACTERS.
# LIKE AND NOT LIKE ARE BASICALLY USED TO PATTERN MATCHING.
 
 #BETWEEN : HELPS TO DESIGNATE THE INTERVAL TO WHICH THE VALUE BELONGS. THAT IS WHY IT IS ALWAYS USED WITH AND 
 #OPERATOR.
 #EG:
 SELECT * FROM EMPLOYEES WHERE HIRE_DATE BETWEEN '1990-01-01' AND '2000-01-01';
 SELECT * FROM SALARIES WHERE SALARY BETWEEN 66000 AND 77000;
 SELECT * FROM EMPLOYEES WHERE EMP_NO NOT BETWEEN 10004 AND 10012;
 SELECT * FROM DEPARTMENTS WHERE DEPT_NO BETWEEN 'D003' AND 'D006';
 
 # NOT NULL CLAUSE IS USED IF WE WANT TO RETRIEVE NON NULL VALUES FROM A COLUMN.
 SELECT FIRST_NAME FROM EMPLOYEES WHERE FIRST_NAME IS NOT NULL;
 SELECT DEPT_NAME FROM DEPARTMENTS WHERE DEPT_NAME IS NOT NULL;
 #DISTINCT : IF WE WANT DISTINCT VALUES
 SELECT DISTINCT GENDER FROM EMPLOYEES;
 SELECT DISTINCT HIRE_DATE FROM EMPLOYEES;
 
 #COUNT : COUNTS THE NON NULL VALUES IN A COLUMN IE GIVES NON NULL ROWS.
 SELECT COUNT(EMP_NO) FROM EMPLOYEES;
 SELECT COUNT(DISTINCT FIRST_NAME) FROM EMPLOYEES;
 # WHILE USING COUNT THE DISTINCT KEYWORD IS NOT WRITTEN AFTER SELECT. IT IS WRITTEN IN COUNT
 # BRACKETS.
 SELECT COUNT(SALARY) FROM SALARIES WHERE SALARY>=100000;
 SELECT COUNT(*) FROM EMPLOYEES;
 
 # ORDER BY : THIS CLAUSE BASICALLY ORDERS THE GIVEN QUERY WITH THE GIVEN PARAMETER.
 SELECT * FROM EMPLOYEES ORDER BY FIRST_NAME;
 SELECT * FROM EMPLOYEES ORDER BY HIRE_DATE;
 
 # GROUP BY:  WHEN WORKING IN SQL, RESULTS CAN BE GROUPED ACCORDING TO A SPECIFIC
 # FIELD OR FIELDS. THIS IS DONE BY GROUP BY. GROUP BY MUST BE PLACED IMMEDIATELY AFTER WHERE AND
 # JUST BEFORE ORDER BY. SUPPOSE WE WANT TO KNOW HOW MANY TIMES FIRST NAME HAS BEEN COME. MEANING
 # HOW MANY TIMES A PARTICULAR NAME IS THERE WE CAN SUE GROUP BY THERE. 
 # A STRICT RULE IS THAT WHATEVER WE USE IN COUNT IN GROUPY BY JUST USE IT BEFORE SELECT.
 #EG:
SELECT COUNT(FIRST_NAME) FROM EMPLOYEES GROUP BY FIRST_NAME;
# THIS MEANS WE ARE GETTING COUNT OF FIRST NAMES AND IN TURN WE ARE ALSO GROUPING THOSE COUNTS 
# ACCORDING TO GROUP BY.
SELECT FIRST_NAME, COUNT(FIRST_NAME) FROM EMPLOYEES GROUP BY FIRST_NAME ORDER BY FIRST_NAME DESC;

# AS : AS IS USED TO CHANGE THE COLUMN NAME.
SELECT FIRST_NAME AS NAMES_PEOPLE,COUNT(FIRST_NAME) AS NAMES_COUNT FROM EMPLOYEES GROUP BY FIRST_NAME ORDER BY FIRST_NAME;
SELECT SALARY, COUNT(EMP_NO) AS EMP_WITH_SAME_SALARY FROM SALARIES WHERE SALARY>80000 GROUP BY SALARY ORDER BY SALARY;

# HAVING: HAVING IS LIKE WHERE BUT IT IS USED BETWEEN GROUP BY AND ORDER BY CALUSE.
#EG: FIND ALL FIRST NAMES WHERE FIRST NAMES ARE MORE THAN 250 TIMES. 
SELECT FIRST_NAME,COUNT(FIRST_NAME) AS NAMES_COUNT FROM EMPLOYEES GROUP BY FIRST_NAME
HAVING COUNT(FIRST_NAME)>250 ORDER BY FIRST_NAME;
# IN WHERE CLAUSE YOU CANNOT USE AGGREGATE FUNCTIONS WITH IT WHEREAS YOU CAN USE IT WITH HAVING.
SELECT FIRST_NAME , COUNT(FIRST_NAME) FROM EMPLOYEES WHERE HIRE_DATE>'1999-01-01' GROUP BY FIRST_NAME
HAVING COUNT(FIRST_NAME)<200 ORDER BY FIRST_NAME;
# THE ABOVE QUERY MEANS SELECTING ALL EMPLOYEES WHO HAVE BEEN HIRED AFTER 1 JAN 1999 HAVING NAMES LESS THAN 200.

# IF USING AGGREGATE FUNCTIONS USE HAVING, IF GENERAL QUERIES USE WHERE.

# LIMITS :  IF WE WANT A CERTAIN NUMBER OF ROWS OR WE WANT TO LIMIT OUR OUTPUT TO CERTAIN VALUES WE USE LIMIT.
#EG:
SELECT * FROM EMPLOYEES LIMIT 100;

# INSERTION IN THE TABLE
INSERT INTO EMPLOYEES VALUES(
13,
'2000-02-13',
'Ojas',
'Gupta',
'M',
'2023-01-16');
SELECT * FROM EMPLOYEES WHERE EMP_NO=13;

#UPDATE : 

UPDATE EMPLOYEES 
SET 
FIRST_NAME='RITU',
LAST_NAME='GUPTA',
BIRTH_DATE='1972-09-08',
GENDER='F'
WHERE EMP_NO=13;

UPDATE EMPLOYEES SET
BIRTH_DATE='1972-09-08',
FIRST_NAME='RITU',
LAST_NAME='GUPTA',
GENDER='F',
HIRE_DATE='2023-01-16'
WHERE EMP_NO=96825;
# COMMIT : SAVES THE CURRENT STATE OF THE DATABASE
# ROLLBACK : GETS TO THE PREVIOUS STATE OF THE DATABASE.
DELETE FROM EMPLOYEES WHERE EMP_NO=13;
SELECT * FROM EMPLOYEES WHERE EMP_NO=96825;
COMMIT;

DELETE FROM DEPARTMENTS WHERE DEPT_NO='d010';
ROLLBACK;
SELECT *FROM DEPARTMENTS ORDER BY DEPT_NO LIMIT 10;

# -------------------------------------------- JOINS----------------------------------------

# INNER JOINS : INNER JOINS ARE BASICALLY THE INTERSECTION OF TWO TABLES WITH SAME COLUMN(S) TO RELATE 
# WITH EACH OTEHR.
USE EMPLOYEES;
SELECT E.EMP_NO, E.FIRST_NAME, E.LAST_NAME, D.DEPT_NO,E.HIRE_DATE FROM EMPLOYEES E
INNER JOIN DEPT_MANAGER D ON E.EMP_NO=D.EMP_NO ORDER BY E.EMP_NO;

# LEFT JOINS : LEFT JOINS CAN DELIVER A LIST WITH VALUES FROM LEFT TABLE THAT DO NOT MATCH ANY ROWS FROM THE 
# RIGHT TABLE. IN SIMPLE WORDS IF WE HAVE TWO TABLES AND HAVE SOME ID'S IN THE FIRST TABLE WHOSE 
# CORRESPONSING DATA IS NOT AVAILABLE IN THE SECOND TABLE THEN IF WE PERFORM INNER JOIN 
# WE WILL NOT GET THOSE ID'S AS INNER JOIN MEANS DATA WHICH IS COMMON TO BOTH THE VALUES.
# BUT IN LEFT JOIN WE WILL GET THOSE VALUES IF WE LEFT JOIN ON LEFT TABLE.

SELECT E.EMP_NO,E.FIRST_NAME, E.LAST_NAME, D.DEPT_NO, D.FROM_DATE FROM EMPLOYEES E
LEFT JOIN DEPT_MANAGER D ON E.EMP_NO=D.EMP_NO WHERE E.LAST_NAME="Markovitch" ORDER BY
D.DEPT_NO DESC,EMP_NO ASC; 

# RIGHT JOIN : SAME AS LEFT JOIN BUT ARE IMPLEMENTED ON THE RIGHT TABLE.

SELECT E.EMP_NO, D.DEPT_NO, E.FIRST_NAME,E.LAST_NAME, E.HIRE_DATE FROM EMPLOYEES E
INNER JOIN DEPT_MANAGER D ON E.EMP_NO=D.EMP_NO ORDER BY E.EMP_NO DESC;

SELECT E.EMP_NO, E.FIRST_NAME, E.LAST_NAME, E.HIRE_DATE, T.TITLE FROM EMPLOYEES E
INNER JOIN TITLES T ON E.EMP_NO=T.EMP_NO WHERE E.FIRST_NAME= "MARGARETA" AND LAST_NAME="MARKOVITCH";

# CROSS JOIN : A CROSS JOIN WILL TAKE TEH VALUES FROM A CERTAIN TABLE AND JOIN IT WITH ALL THE
#VALUES FROM THE TABLE WE WANT TO JOIN IT WITH.
# IF WE WANT TO JOIN TWO TABLES WITH EMP_NO AND DEPT_NO BUT THE VALUES ARE NOT MATCHABLE WHICH MEANS
# THAT THE DEPARTMENTS ARE 10 BUT THE EMP_NO ARE 500. THEN WE USE CROSS JOIN. CROSS JOIN BASICALLY IS A 
#CARTESIAN PRODUCT OF TWO TABLES WHICH SIMPLY JOINS TWO TABLES WITHOUT MATCHING ANY VALUE;
 SELECT M.DEPT_NO, M.EMP_NO,M.FROM_DATE,M.TO_DATE, D.DEPT_NO FROM DEPT_MANAGER M 
 CROSS JOIN DEPARTMENTS D WHERE D.DEPT_NO='D009';
 
 # JOINING MORE THAN TWO TABLES : JUST JOIN ONE TABLE WITH THE SECOND ONE AND THE SECOND ONE WITH THE THIRD ONE.
 SELECT E.EMP_NO,E.FIRST_NAME, E.LAST_NAME, E.HIRE_DATE, T.TITLE, D.FROM_DATE, DM.DEPT_NAME
 FROM EMPLOYEES E INNER JOIN TITLES T ON E.EMP_NO=T.EMP_NO
 JOIN DEPT_MANAGER D ON T.EMP_NO=D.EMP_NO INNER JOIN DEPARTMENTS DM ON
 D.DEPT_NO=DM.DEPT_NO ORDER BY E.EMP_NO;
 
 # COMLPEX QUERY USING JOINS ON FOUR TABLES.
SELECT E.GENDER, COUNT(DM.EMP_NO) FROM EMPLOYEES E
INNER JOIN DEPT_MANAGER DM ON E.EMP_NO=DM.EMP_NO GROUP BY E.GENDER;

# SUBQUERIES : QUERIES EMBEDDED INSIDE A QUERY.
# THEY ARE A PART OF ANOTHER QUERY CALLED THE OUTER QUERY.
# THE SQL ENGINE PROCESS : THE INNER QUERY IS EXECUTED FIRST. AFTER THE EXECUTION OF THE INNER QUERY
# THE RESULT IS USED FOR THE EXECUTION OF THE OUTER QUERY.
SELECT
*FROM
dept_manager
WHERE
emp_no IN (SELECT
emp_no
FROM
employees
WHERE
hire_date BETWEEN '1990-01-01' AND '1995-01-01'); 

# EXISTS , NON EXISTS : CHECKS WHETHER CERTAIN ROW VALUES ARE FOUND WIHTIN A SUBQUERY.
# THIS CHECK IS CONDUCTED ROW BY ROW.
# IT RETURNS A BOOLEAN VALUE;
SELECT * FROM EMPLOYEES WHERE EMP_NO IN(SELECT EMP_NO FROM TITLES WHERE TITLE="ASSISTANT ENGINEER") 
ORDER BY EMP_NO;

USE EMPLOYEES;

#ROUTINES : A USUAL, FIXED ACTON OR SERIES OF ACTIONS REPEATED PERIODICALLY.
# STORED ROUTINE : AN SQL STATEMENT OR A SET OF STATEMENTS THAT CAN BE STORED ON A DATABASE SERVER.
# BASICALLY IF WE HAVE A SET OF QUERY THAT IS REPEATED PERIODICALLY THEN WE DONT NEED TO WRITE 
# IT EVERYTIME WE NEED THE SAME OUTPUT. WE CAN STORE THAT PIECE OF CODE IN OUR DATABASE SERVER.
#STORED PROCEDURE :
# EG:
DELIMITER $$
CREATE PROCEDURE AVG_SALARY()
BEGIN
SELECT AVG(SALARY) FROM SALARIES;
END$$
DELIMITER ;
CALL AVG_SALARY()

DELIMITER $$
CREATE PROCEDURE JOIN_TABLE(IN P_EMP_NO INTEGER)
BEGIN
SELECT E.FIRST_NAME, E.LAST_NAME, E.HIRE_DATE , S.SALARY FROM EMPLOYEES E
INNER JOIN SALARIES S ON E.EMP_NO=S.EMP_NO
WHERE E.EMP_NO=P_EMP_NO;
END$$
DELIMITER ;
CALL JOIN_TABLE(11300);

# WHEN WWRITING PROCEDURES WITH IN PARAMETERS, WE USE WHERE CLAUSE TO RELATE TO THE VALUE THAT IS NEEDED TO
#RUN THE QUERY. IN THE CASE OF THE ABOVE QUERY WE RELATED EMP_NO BECAUSE WE NEED EMP_NO AS INPUT
# THIS IS AS SAME AS A FUNCTION CALL IN A PROGRAMMING LANGUAGE.

# TRIGGERS : TRIGGERS ARE THOSE STORED SQL STATEMENTS THAT ARE INVOKED AUTOMATICALLY AFTER EVERY 
# DML STATEMENTS LIKE UPDATE, DELETE AND INSERT
#EG :
USE EMPLOYEES;
DELIMITER $$ 
CREATE TRIGGER CHECK_SALARY
BEFORE INSERT ON SALARIES
FOR EACH ROW
BEGIN
IF NEW.SALARY<0 THEN
    SET NEW.SALARY=0;
    END IF;
END $$
DELIMITER ;
INSERT INTO SALARIES VALUES ( 10001,-6594,'2022-02-13','2025-02-12');
SELECT * FROM SALARIES ORDER BY SALARY;

# HERE WE CREATED A TRIGGER AND CHECK ITS FUNCTIONING AND IT WORKING COMPLETELY FINE.
# BEFORE UPDATE TRIGGER
DELIMITER $$
CREATE TRIGGER CHECK_OLD_SALARY
BEFORE UPDATE ON SALARIES
FOR EACH ROW
BEGIN
IF NEW.SALARY<0
THEN SET NEW.SALARY=OLD.SALARY;
END IF;
END$$
DELIMITER ;
INSERT INTO SALARIES VALUES( 10001, 100000,'2022-9-22','2022-11-15');
SELECT * FROM SALARIES WHERE EMP_NO =10001;
UPDATE SALARIES SET SALARY=-50000 WHERE TO_DATE='2022-11-15';
SELECT * FROM SALARIES WHERE EMP_NO=10001;

# BEFORE UPDATE TRIGGER ALSO WORKED.
USE EMPLOYEES;
SELECT E.FIRST_NAME, E.LAST_NAME, M.EMP_NO, M.FROM_DATE, M.TO_DATE,M.DEPT_NO
FROM EMPLOYEES E JOIN DEPT_MANAGER M ON E.EMP_NO=M.EMP_NO ORDER BY E.FIRST_NAME LIMIT 10;